// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";
import * as List from "rescript/lib/es6/list.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as React from "react";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Reprocessing from "reprocessing/src/Reprocessing.bs.js";
import * as Reprocessing_Env from "reprocessing/src/Reprocessing_Env.bs.js";
import * as Reprocessing_Draw from "reprocessing/src/Reprocessing_Draw.bs.js";
import * as Reprocessing_Utils from "reprocessing/src/Reprocessing_Utils.bs.js";

var dataCarrier = {
  strokes: /* [] */0
};

function getStrokes(param) {
  return dataCarrier.strokes;
}

function setStrokes(ls) {
  dataCarrier.strokes = ls;
  
}

function toString(s) {
  return "p1: " + String(s.sp.p1.xi) + ", " + String(s.sp.p1.yi) + "; p2: " + String(s.sp.p2.xi) + ", " + String(s.sp.p2.yi);
}

function stringOfStrokes(_label, _strokes) {
  while(true) {
    var strokes = _strokes;
    var label = _label;
    if (!strokes) {
      return label + "\n---\n";
    }
    _strokes = strokes.tl;
    _label = label + "\n" + toString(strokes.hd);
    continue ;
  };
}

function EditorComponent(Props) {
  var state = Props.state;
  var id = "divider-editor";
  var bgColor = Reprocessing_Utils.color(255, 250, 250, 255);
  var basicStrokeColor = Reprocessing_Utils.color(90, 160, 245, 255);
  var dragLineColor = Reprocessing_Utils.color(205, 0, 0, 255);
  var dotColor = Reprocessing_Utils.color(0, 0, 0, 255);
  var frameColor = Reprocessing_Utils.color(200, 200, 0, 55);
  var rColor = function (param) {
    return Reprocessing_Utils.color(Reprocessing_Utils.random(0, 255), Reprocessing_Utils.random(0, 255), Reprocessing_Utils.random(0, 255), 255);
  };
  var wToG = function (s, param) {
    return {
            xi: Reprocessing_Utils.round((param[0] - 20) / s.dg.dotSpacing) | 0,
            yi: Reprocessing_Utils.round((900 - param[1] - 20) / s.dg.dotSpacing) | 0
          };
  };
  var gToW = function (s, g) {
    return [
            Math.imul(g.xi, s.dg.dotSpacing) + 20 | 0,
            900 - (Math.imul(g.yi, s.dg.dotSpacing) + 20 | 0) | 0
          ];
  };
  var makeOuterStrokes = function (dg) {
    var right = dg.wCount - 1 | 0;
    var bot = dg.hCount - 1 | 0;
    return {
            hd: {
              sp: {
                p1: {
                  xi: 0,
                  yi: 0
                },
                p2: {
                  xi: 0,
                  yi: bot
                }
              },
              color: rColor(undefined)
            },
            tl: {
              hd: {
                sp: {
                  p1: {
                    xi: 0,
                    yi: bot
                  },
                  p2: {
                    xi: right,
                    yi: bot
                  }
                },
                color: rColor(undefined)
              },
              tl: {
                hd: {
                  sp: {
                    p1: {
                      xi: right,
                      yi: bot
                    },
                    p2: {
                      xi: right,
                      yi: 0
                    }
                  },
                  color: rColor(undefined)
                },
                tl: {
                  hd: {
                    sp: {
                      p1: {
                        xi: 0,
                        yi: 0
                      },
                      p2: {
                        xi: right,
                        yi: 0
                      }
                    },
                    color: rColor(undefined)
                  },
                  tl: /* [] */0
                }
              }
            }
          };
  };
  var intSegment = function (first, last, current) {
    if (first === last) {
      return current;
    } else {
      return {
              hd: first,
              tl: intSegment(first + 1 | 0, last, current)
            };
    }
  };
  var makeDots = function (dg) {
    var xs = intSegment(0, dg.wCount, /* [] */0);
    var ys = intSegment(0, dg.hCount, /* [] */0);
    var h = function (x) {
      return List.map((function (u) {
                    return {
                            xi: x,
                            yi: u
                          };
                  }), ys);
    };
    return List.flatten(List.map(h, xs));
  };
  var nonDegenerate = function (s) {
    return !Caml_obj.caml_equal(s.sp.p1, s.sp.p2);
  };
  var orderY = function (s) {
    if (s.sp.p1.yi < s.sp.p2.yi) {
      return s;
    } else {
      return {
              sp: {
                p1: s.sp.p2,
                p2: s.sp.p1
              },
              color: s.color
            };
    }
  };
  var orderX = function (s) {
    if (s.sp.p1.xi < s.sp.p2.xi) {
      return s;
    } else {
      return {
              sp: {
                p1: s.sp.p2,
                p2: s.sp.p1
              },
              color: s.color
            };
    }
  };
  var compXY = function (s1, s2) {
    var dx = Caml.caml_int_compare(s1.sp.p1.xi, s2.sp.p1.xi);
    var dy = Caml.caml_int_compare(s1.sp.p1.yi, s2.sp.p1.yi);
    if (dx === 0) {
      return dy;
    } else {
      return dx;
    }
  };
  var compYX = function (s1, s2) {
    var dx = Caml.caml_int_compare(s1.sp.p1.xi, s2.sp.p1.xi);
    var dy = Caml.caml_int_compare(s1.sp.p1.yi, s2.sp.p1.yi);
    if (dy === 0) {
      return dx;
    } else {
      return dy;
    }
  };
  var overlapH = function (s1, s2) {
    if (s1.sp.p1.yi === s2.sp.p1.yi) {
      return s2.sp.p1.xi <= s1.sp.p2.xi;
    } else {
      return false;
    }
  };
  var overlapV = function (s1, s2) {
    if (s1.sp.p1.xi === s2.sp.p1.xi) {
      return s2.sp.p1.yi <= s1.sp.p2.yi;
    } else {
      return false;
    }
  };
  var mergeH = function (s1, s2) {
    return {
            sp: {
              p1: {
                xi: s1.sp.p1.xi < s2.sp.p1.xi ? s1.sp.p1.xi : s2.sp.p1.xi,
                yi: s1.sp.p1.yi
              },
              p2: {
                xi: s1.sp.p2.xi > s2.sp.p2.xi ? s1.sp.p2.xi : s2.sp.p2.xi,
                yi: s1.sp.p1.yi
              }
            },
            color: s1.color
          };
  };
  var mergeV = function (s1, s2) {
    return {
            sp: {
              p1: {
                xi: s1.sp.p1.xi,
                yi: s1.sp.p1.xi < s2.sp.p1.yi ? s1.sp.p1.xi : s2.sp.p1.yi
              },
              p2: {
                xi: s1.sp.p1.xi,
                yi: s1.sp.p2.xi > s2.sp.p2.yi ? s1.sp.p2.xi : s2.sp.p2.yi
              }
            },
            color: s1.color
          };
  };
  var merge = function (_strokes, overlapTest, mergeR) {
    while(true) {
      var strokes = _strokes;
      if (!strokes) {
        return strokes;
      }
      var match = strokes.tl;
      if (!match) {
        return strokes;
      }
      var _a = strokes.hd;
      var tl = match.tl;
      var b = match.hd;
      if (!Curry._2(overlapTest, _a, b)) {
        return {
                hd: _a,
                tl: merge({
                      hd: b,
                      tl: tl
                    }, overlapTest, mergeR)
              };
      }
      _strokes = {
        hd: Curry._2(mergeR, _a, b),
        tl: tl
      };
      continue ;
    };
  };
  var clean = function (strokes, _env) {
    var s1 = List.filter(nonDegenerate)(strokes);
    var sh = List.filter(function (s) {
            return s.sp.p1.yi === s.sp.p2.yi;
          })(s1);
    var sv = List.filter(function (s) {
            return s.sp.p1.xi === s.sp.p2.xi;
          })(s1);
    var sho = List.map(orderX, sh);
    var svo = List.map(orderY, sv);
    var shSorted = List.sort(compYX, sho);
    var svSorted = List.sort(compXY, svo);
    var refinedH = merge(shSorted, overlapH, mergeH);
    var refinedV = merge(svSorted, overlapV, mergeV);
    return List.append(refinedH, refinedV);
  };
  var buildGeom = function (s) {
    var frameWidth = s.data.width;
    var frameHeight = s.data.depth;
    var dotGap = s.data.spacing;
    var extendedWidth = dotGap * Math.ceil(frameWidth / dotGap);
    var extendedHeight = dotGap * Math.ceil(frameHeight / dotGap);
    var ratio = Caml.caml_float_min(860 / extendedWidth, 860 / extendedHeight);
    var dotSpacing = ratio * dotGap | 0;
    var rratio = dotSpacing / dotGap;
    var wCount = 1 + (Math.ceil(frameWidth / dotGap) | 0) | 0;
    var hCount = 1 + (Math.ceil(frameHeight / dotGap) | 0) | 0;
    var frameHeightPixels = Math.floor(rratio * frameHeight) | 0;
    var frameWidthPixels = Math.floor(rratio * frameWidth) | 0;
    return {
            wCount: wCount,
            hCount: hCount,
            dotSpacing: dotSpacing,
            frameHeightPixels: frameHeightPixels,
            frameWidthPixels: frameWidthPixels
          };
  };
  var strokeCompare = function (s1, s2) {
    return Caml_obj.caml_compare(s1.sp, s2.sp);
  };
  var setup = function (env) {
    Reprocessing_Draw.strokeWeight(2, env);
    Reprocessing_Env.size(900, 900, env);
    var d = buildGeom(state);
    var newStrokeList = List.sort_uniq(strokeCompare, state.newStart ? makeOuterStrokes(d) : state.drawing);
    var q_dragStart = {
      xi: 0,
      yi: 0
    };
    var q_dragNow = {
      xi: 0,
      yi: 0
    };
    var q_dots = makeDots(d);
    var q = {
      p: /* Base */0,
      dragging: false,
      dragStart: q_dragStart,
      dragNow: q_dragNow,
      strokeColor: basicStrokeColor,
      strokeList: newStrokeList,
      dots: q_dots,
      oldStrokes: /* [] */0,
      dg: d
    };
    dataCarrier.strokes = newStrokeList;
    return q;
  };
  var drawFrame = function (s, env) {
    Reprocessing_Draw.stroke(frameColor, env);
    Reprocessing_Draw.strokeWeight(7, env);
    var h = s.dg.frameHeightPixels;
    var w = s.dg.frameWidthPixels;
    var ll = [
      20,
      880
    ];
    var ur_0 = w + 20 | 0;
    var ur_1 = 900 - (h + 20 | 0) | 0;
    var ur = [
      ur_0,
      ur_1
    ];
    Reprocessing_Draw.line(ll, [
          20,
          900 - (h + 20 | 0) | 0
        ], env);
    Reprocessing_Draw.line(ll, [
          w + 20 | 0,
          880
        ], env);
    Reprocessing_Draw.line(ur, [
          20,
          900 - (h + 20 | 0) | 0
        ], env);
    Reprocessing_Draw.line(ur, [
          w + 20 | 0,
          880
        ], env);
    return Reprocessing_Draw.strokeWeight(2, env);
  };
  var drawGrid = function (s, e) {
    Reprocessing_Draw.fill(dotColor, e);
    Reprocessing_Draw.noStroke(e);
    List.map((function (p) {
            return Reprocessing_Draw.ellipsef(gToW(s, p), 2.5, 2.5, e);
          }), s.dots);
    
  };
  var drawStrokes = function (state, env) {
    Reprocessing_Draw.noFill(env);
    Reprocessing_Draw.stroke(basicStrokeColor, env);
    var x0 = state.dg.frameWidthPixels + 20 | 0;
    var y0 = 900 - (state.dg.frameHeightPixels + 20 | 0) | 0;
    List.map((function (s) {
            var match = gToW(state, s.sp.p1);
            var p1_0 = Caml.caml_float_min(match[0], x0);
            var p1_1 = Caml.caml_float_max(match[1], y0);
            var p1 = [
              p1_0,
              p1_1
            ];
            var match$1 = gToW(state, s.sp.p2);
            var p2_0 = Caml.caml_float_min(match$1[0], x0);
            var p2_1 = Caml.caml_float_max(match$1[1], y0);
            var p2 = [
              p2_0,
              p2_1
            ];
            return Reprocessing_Draw.linef(p1, p2, env);
          }), state.strokeList);
    
  };
  var drawCurrentLine = function (state, env) {
    if (state.dragging === false) {
      return ;
    } else {
      Reprocessing_Draw.noFill(env);
      Reprocessing_Draw.stroke(dragLineColor, env);
      return Reprocessing_Draw.linef(gToW(state, state.dragStart), gToW(state, state.dragNow), env);
    }
  };
  var align = function (param, param$1) {
    var y1 = param$1.yi;
    var x1 = param$1.xi;
    var y0 = param.yi;
    var x0 = param.xi;
    var adx = Pervasives.abs(x0 - x1 | 0);
    var ady = Pervasives.abs(y0 - y1 | 0);
    if (adx < ady) {
      return {
              xi: x0,
              yi: y1
            };
    } else {
      return {
              xi: x1,
              yi: y0
            };
    }
  };
  var findNearest = function (s, param, strokes, limit) {
    var y = param[1];
    var x = param[0];
    var gp = wToG(s, [
          x,
          y
        ]);
    var xgf = (x - 20 | 0) / s.dg.dotSpacing;
    var ygf = ((900 - y | 0) - 20 | 0) / s.dg.dotSpacing;
    var dd = function (x, y, s) {
      var match = s.sp.p1;
      var x1 = match.xi;
      var match$1 = s.sp.p2;
      if (x1 === match$1.xi) {
        return Math.abs(x - x1);
      } else {
        return Math.abs(y - match.yi);
      }
    };
    var best = function (sAndDList) {
      if (!sAndDList) {
        return ;
      }
      var match = sAndDList.tl;
      var q1 = sAndDList.hd;
      if (!match) {
        return [
                q1[0],
                q1[1]
              ];
      }
      var match$1 = best({
            hd: match.hd,
            tl: match.tl
          });
      if (match$1 !== undefined) {
        var rDist = match$1[1];
        if (Caml_obj.caml_lessequal(q1[1], rDist)) {
          return q1;
        } else {
          return [
                  match$1[0],
                  rDist
                ];
        }
      }
      throw {
            RE_EXN_ID: "Match_failure",
            _1: [
              "EditorComponent.res",
              453,
              12
            ],
            Error: new Error()
          };
    };
    var containingStrokes = List.filter(function (s) {
            var j = gp.yi;
            var i = gp.xi;
            var match = s.sp.p1;
            var y1 = match.yi;
            var x1 = match.xi;
            var match$1 = s.sp.p2;
            var y2 = match$1.yi;
            var x2 = match$1.xi;
            var match$2 = x1 === x2;
            var match$3 = y1 === y2;
            if (match$2) {
              if (match$3) {
                if (x1 === i) {
                  return y1 === j;
                } else {
                  return false;
                }
              } else if (x1 === i) {
                return Math.imul(y1 - j | 0, y2 - j | 0) <= 0;
              } else {
                return false;
              }
            } else if (match$3 && y1 === j) {
              return Math.imul(x1 - i | 0, x2 - i | 0) <= 0;
            } else {
              return false;
            }
          })(strokes);
    var sAndD = List.map((function (s) {
            return [
                    s,
                    dd(xgf, ygf, s)
                  ];
          }), containingStrokes);
    var limitedSAndD = List.filter(function (param) {
            return param[1] <= limit;
          })(sAndD);
    var match = best(limitedSAndD);
    if (match !== undefined) {
      return match[0];
    }
    
  };
  var newStroke = function (_p1, _p2) {
    while(true) {
      var p2 = _p2;
      var p1 = _p1;
      if (p1.xi > p2.xi) {
        _p2 = p1;
        _p1 = p2;
        continue ;
      }
      if (!(p1.xi === p2.xi && p1.yi > p2.yi)) {
        return {
                sp: {
                  p1: p1,
                  p2: p2
                },
                color: basicStrokeColor
              };
      }
      _p2 = p1;
      _p1 = p2;
      continue ;
    };
  };
  var draw = function (state, env) {
    Reprocessing_Draw.background(bgColor, env);
    drawGrid(state, env);
    drawFrame(state, env);
    drawStrokes(state, env);
    drawCurrentLine(state, env);
    var press = Reprocessing_Env.mousePressed(env);
    var release = state.dragging && !press;
    var shift = Reprocessing_Env.key(/* LeftShift */57, env) || Reprocessing_Env.key(/* RightShift */61, env);
    var mouse = Reprocessing_Env.mousePressed(env);
    var match = Reprocessing_Env.mouse(env);
    var y = match[1];
    var x = match[0];
    var loc = wToG(state, [
          x,
          y
        ]);
    var s = state.p;
    var newPhase;
    var exit = 0;
    switch (s) {
      case /* Base */0 :
      case /* Shift */1 :
          exit = 1;
          break;
      case /* DelStart */2 :
          newPhase = /* DelDone */3;
          break;
      case /* DelDone */3 :
      case /* Neutral */4 :
          exit = 2;
          break;
      case /* Dragging */5 :
          newPhase = shift ? (
              mouse ? /* Dragging */5 : /* Shift */1
            ) : (
              mouse ? /* Dragging */5 : /* Base */0
            );
          break;
      
    }
    switch (exit) {
      case 1 :
          newPhase = shift ? (
              mouse ? /* DelStart */2 : /* Shift */1
            ) : (
              mouse ? /* Dragging */5 : /* Base */0
            );
          break;
      case 2 :
          newPhase = shift ? (
              mouse ? /* DelDone */3 : /* Shift */1
            ) : (
              mouse ? /* Neutral */4 : /* Base */0
            );
          break;
      
    }
    var newDragStart = state.p === /* Base */0 && newPhase === /* Dragging */5 ? loc : state.dragStart;
    var newDragNow = state.p === /* Dragging */5 && newPhase === /* Dragging */5 ? align(state.dragStart, loc) : state.dragStart;
    var newStrokeList;
    if (state.p === /* Dragging */5 && newPhase !== /* Dragging */5) {
      newStrokeList = clean({
            hd: newStroke(state.dragStart, align(state.dragStart, loc)),
            tl: state.strokeList
          }, env);
    } else if (state.p === /* DelStart */2 && newPhase === /* DelDone */3) {
      var closest = findNearest(state, [
            x,
            y
          ], state.strokeList, 0.5);
      newStrokeList = closest !== undefined ? List.filter(function (s) {
                if (Caml_obj.caml_notequal(s.sp.p1, closest.sp.p1)) {
                  return true;
                } else {
                  return Caml_obj.caml_notequal(s.sp.p2, closest.sp.p2);
                }
              })(state.strokeList) : state.strokeList;
    } else {
      newStrokeList = state.strokeList;
    }
    dataCarrier.strokes = Caml_obj.caml_notequal(newStrokeList, dataCarrier.strokes) ? newStrokeList : dataCarrier.strokes;
    return {
            p: newPhase,
            dragging: press ? true : (
                release ? false : state.dragging
              ),
            dragStart: newDragStart,
            dragNow: newDragNow,
            strokeColor: state.strokeColor,
            strokeList: Caml_obj.caml_notequal(newStrokeList, state.strokeList) ? (dataCarrier.strokes = newStrokeList, newStrokeList) : state.strokeList,
            dots: state.dots,
            oldStrokes: Caml_obj.caml_notequal(newStrokeList, state.strokeList) ? state.strokeList : state.oldStrokes,
            dg: state.dg
          };
  };
  React.useEffect(function () {
        Reprocessing.setScreenId(id);
        Reprocessing.run(setup, undefined, draw, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined);
        
      });
  return React.createElement("canvas", {
              id: id
            });
}

var make = EditorComponent;

export {
  dataCarrier ,
  getStrokes ,
  setStrokes ,
  toString ,
  stringOfStrokes ,
  make ,
  
}
/* react Not a pure module */
