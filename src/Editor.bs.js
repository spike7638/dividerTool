// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";
import * as List from "rescript/lib/es6/list.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Reprocessing_Env from "reprocessing/src/Reprocessing_Env.bs.js";
import * as Reprocessing_Draw from "reprocessing/src/Reprocessing_Draw.bs.js";
import * as Reprocessing_Utils from "reprocessing/src/Reprocessing_Utils.bs.js";

var extendedWidth = 10.0 * Math.ceil(65.0 / 10.0);

var extendedHeight = 10.0 * Math.ceil(85.0 / 10.0);

var ratio = Caml.caml_float_min(860 / extendedWidth, 860 / extendedHeight);

var dotSpacing = ratio * 10.0 | 0;

var wCount = 1 + (Math.ceil(65.0 / 10.0) | 0) | 0;

var hCount = 1 + (Math.ceil(85.0 / 10.0) | 0) | 0;

var drawingHeight = Math.floor(ratio * 85.0) | 0;

var drawingWidth = Math.floor(ratio * 65.0) | 0;

var bgColor = Reprocessing_Utils.color(255, 250, 250, 255);

var basicStrokeColor = Reprocessing_Utils.color(90, 160, 245, 255);

var dragLineColor = Reprocessing_Utils.color(205, 0, 0, 255);

var dotColor = Reprocessing_Utils.color(0, 0, 0, 255);

var frameColor = Reprocessing_Utils.color(200, 200, 0, 55);

var dataCarrier = {
  strokes: /* [] */0
};

function getStrokes(param) {
  return dataCarrier.strokes;
}

function rColor(param) {
  return Reprocessing_Utils.color(Reprocessing_Utils.random(0, 255), Reprocessing_Utils.random(0, 255), Reprocessing_Utils.random(0, 255), 255);
}

function wToG(param) {
  return {
          xi: Reprocessing_Utils.round((param[0] - 20) / dotSpacing) | 0,
          yi: Reprocessing_Utils.round((900 - param[1] - 20) / dotSpacing) | 0
        };
}

function gToW(g) {
  return [
          Math.imul(g.xi, dotSpacing) + 20 | 0,
          900 - (Math.imul(g.yi, dotSpacing) + 20 | 0) | 0
        ];
}

function makeOuterStrokes(param) {
  var right = wCount - 1 | 0;
  var bot = hCount - 1 | 0;
  return {
          hd: {
            sp: {
              p1: {
                xi: 0,
                yi: 0
              },
              p2: {
                xi: 0,
                yi: bot
              }
            },
            color: rColor(undefined)
          },
          tl: {
            hd: {
              sp: {
                p1: {
                  xi: 0,
                  yi: bot
                },
                p2: {
                  xi: right,
                  yi: bot
                }
              },
              color: rColor(undefined)
            },
            tl: {
              hd: {
                sp: {
                  p1: {
                    xi: right,
                    yi: bot
                  },
                  p2: {
                    xi: right,
                    yi: 0
                  }
                },
                color: rColor(undefined)
              },
              tl: {
                hd: {
                  sp: {
                    p1: {
                      xi: right,
                      yi: 0
                    },
                    p2: {
                      xi: 0,
                      yi: 0
                    }
                  },
                  color: rColor(undefined)
                },
                tl: /* [] */0
              }
            }
          }
        };
}

function intSegment(first, last, current) {
  if (first === last) {
    return current;
  } else {
    return {
            hd: first,
            tl: intSegment(first + 1 | 0, last, current)
          };
  }
}

function makeDots(param) {
  var xs = intSegment(0, wCount, /* [] */0);
  var ys = intSegment(0, hCount, /* [] */0);
  var h = function (x) {
    return List.map((function (u) {
                  return {
                          xi: x,
                          yi: u
                        };
                }), ys);
  };
  return List.flatten(List.map(h, xs));
}

function nonDegenerate(s) {
  return !Caml_obj.caml_equal(s.sp.p1, s.sp.p2);
}

function orderY(s) {
  if (s.sp.p1.yi < s.sp.p2.yi) {
    return s;
  } else {
    return {
            sp: {
              p1: s.sp.p2,
              p2: s.sp.p1
            },
            color: s.color
          };
  }
}

function orderX(s) {
  if (s.sp.p1.xi < s.sp.p2.xi) {
    return s;
  } else {
    return {
            sp: {
              p1: s.sp.p2,
              p2: s.sp.p1
            },
            color: s.color
          };
  }
}

function compXY(s1, s2) {
  var dx = Caml.caml_int_compare(s1.sp.p1.xi, s2.sp.p1.xi);
  var dy = Caml.caml_int_compare(s1.sp.p1.yi, s2.sp.p1.yi);
  if (dx === 0) {
    return dy;
  } else {
    return dx;
  }
}

function compYX(s1, s2) {
  var dx = Caml.caml_int_compare(s1.sp.p1.xi, s2.sp.p1.xi);
  var dy = Caml.caml_int_compare(s1.sp.p1.yi, s2.sp.p1.yi);
  if (dy === 0) {
    return dx;
  } else {
    return dy;
  }
}

function overlapH(s1, s2) {
  if (s1.sp.p1.yi === s2.sp.p1.yi) {
    return s2.sp.p1.xi <= s1.sp.p2.xi;
  } else {
    return false;
  }
}

function overlapV(s1, s2) {
  if (s1.sp.p1.xi === s2.sp.p1.xi) {
    return s2.sp.p1.yi <= s1.sp.p2.yi;
  } else {
    return false;
  }
}

function mergeH(s1, s2) {
  return {
          sp: {
            p1: {
              xi: s1.sp.p1.xi < s2.sp.p1.xi ? s1.sp.p1.xi : s2.sp.p1.xi,
              yi: s1.sp.p1.yi
            },
            p2: {
              xi: s1.sp.p2.xi > s2.sp.p2.xi ? s1.sp.p2.xi : s2.sp.p2.xi,
              yi: s1.sp.p1.yi
            }
          },
          color: s1.color
        };
}

function mergeV(s1, s2) {
  return {
          sp: {
            p1: {
              xi: s1.sp.p1.xi,
              yi: s1.sp.p1.xi < s2.sp.p1.yi ? s1.sp.p1.xi : s2.sp.p1.yi
            },
            p2: {
              xi: s1.sp.p1.xi,
              yi: s1.sp.p2.xi > s2.sp.p2.yi ? s1.sp.p2.xi : s2.sp.p2.yi
            }
          },
          color: s1.color
        };
}

function toString(s) {
  return "p1: " + (String(s.sp.p1.xi) + (", " + (String(s.sp.p1.yi) + ("; p2: " + (String(s.sp.p2.xi) + (", " + String(s.sp.p2.yi)))))));
}

function showStrokes(_label, _strokes, loc, env) {
  while(true) {
    var strokes = _strokes;
    var label = _label;
    if (!strokes) {
      return Reprocessing_Draw.text(undefined, label, loc, env);
    }
    _strokes = strokes.tl;
    _label = label + ("\n" + toString(strokes.hd));
    continue ;
  };
}

function merge(_strokes, overlapTest, mergeR) {
  while(true) {
    var strokes = _strokes;
    if (!strokes) {
      return /* [] */0;
    }
    var match = strokes.tl;
    var a = strokes.hd;
    if (!match) {
      return {
              hd: a,
              tl: /* [] */0
            };
    }
    var tl = match.tl;
    var b = match.hd;
    if (!Curry._2(overlapTest, a, b)) {
      return {
              hd: a,
              tl: merge({
                    hd: b,
                    tl: tl
                  }, overlapTest, mergeR)
            };
    }
    _strokes = {
      hd: Curry._2(mergeR, a, b),
      tl: tl
    };
    continue ;
  };
}

function clean(strokes, _env) {
  var s1 = List.filter(nonDegenerate)(strokes);
  var sh = List.filter(function (s) {
          return s.sp.p1.yi === s.sp.p2.yi;
        })(s1);
  var sv = List.filter(function (s) {
          return s.sp.p1.xi === s.sp.p2.xi;
        })(s1);
  var sho = List.map(orderX, sh);
  var svo = List.map(orderY, sv);
  var shSorted = List.sort(compYX, sho);
  var svSorted = List.sort(compXY, svo);
  var refinedH = merge(shSorted, overlapH, mergeH);
  var refinedV = merge(svSorted, overlapV, mergeV);
  return List.append(refinedH, refinedV);
}

function setup(env) {
  Reprocessing_Draw.strokeWeight(2, env);
  Reprocessing_Env.size(900, 900, env);
  return {
          p: /* Base */0,
          dragging: false,
          dragStart: {
            xi: 0,
            yi: 0
          },
          dragNow: {
            xi: 0,
            yi: 0
          },
          strokeColor: basicStrokeColor,
          strokeList: makeOuterStrokes(undefined),
          dots: makeDots(undefined),
          oldStrokes: /* [] */0
        };
}

function drawFrame(_state, env) {
  Reprocessing_Draw.stroke(frameColor, env);
  Reprocessing_Draw.strokeWeight(7, env);
  var h = ratio * 85.0;
  var w = ratio * 65.0;
  var m = 20;
  var dh = 900;
  var ll_1 = dh - m;
  var ll = [
    m,
    ll_1
  ];
  var ur_0 = w + m;
  var ur_1 = dh - (h + m);
  var ur = [
    ur_0,
    ur_1
  ];
  Reprocessing_Draw.linef(ll, [
        0.0 + m,
        dh - (h + m)
      ], env);
  Reprocessing_Draw.linef(ll, [
        w + m,
        dh - m
      ], env);
  Reprocessing_Draw.linef(ur, [
        0.0 + m,
        dh - (h + m)
      ], env);
  Reprocessing_Draw.linef(ur, [
        w + m,
        dh - m
      ], env);
  return Reprocessing_Draw.strokeWeight(2, env);
}

function drawGrid(s, e) {
  Reprocessing_Draw.fill(dotColor, e);
  Reprocessing_Draw.noStroke(e);
  List.map((function (p) {
          return Reprocessing_Draw.ellipsef(gToW(p), 2.5, 2.5, e);
        }), s.dots);
  
}

function drawStrokes(state, env) {
  Reprocessing_Draw.noFill(env);
  Reprocessing_Draw.stroke(basicStrokeColor, env);
  var y0 = (900 - (ratio * 85.0 | 0) | 0) - 20 | 0;
  var x0 = (ratio * 65.0 | 0) + 20 | 0;
  List.map((function (s) {
          Reprocessing_Draw.stroke(s.color, env);
          var match = gToW(s.sp.p1);
          var p1_0 = Caml.caml_float_min(match[0], x0);
          var p1_1 = Caml.caml_float_max(match[1], y0);
          var p1 = [
            p1_0,
            p1_1
          ];
          var match$1 = gToW(s.sp.p2);
          var p2_0 = Caml.caml_float_min(match$1[0], x0);
          var p2_1 = Caml.caml_float_max(match$1[1], y0);
          var p2 = [
            p2_0,
            p2_1
          ];
          return Reprocessing_Draw.linef(p1, p2, env);
        }), state.strokeList);
  
}

function drawCurrentLine(state, env) {
  if (state.dragging === false) {
    return ;
  } else {
    Reprocessing_Draw.noFill(env);
    Reprocessing_Draw.stroke(dragLineColor, env);
    return Reprocessing_Draw.linef(gToW(state.dragStart), gToW(state.dragNow), env);
  }
}

function align(param, param$1) {
  var y1 = param$1.yi;
  var x1 = param$1.xi;
  var y0 = param.yi;
  var x0 = param.xi;
  var adx = Pervasives.abs(x0 - x1 | 0);
  var ady = Pervasives.abs(y0 - y1 | 0);
  if (adx < ady) {
    return {
            xi: x0,
            yi: y1
          };
  } else {
    return {
            xi: x1,
            yi: y0
          };
  }
}

function strokeContains(param, s) {
  var j = param.yi;
  var i = param.xi;
  var match = s.sp.p1;
  var y1 = match.yi;
  var x1 = match.xi;
  var match$1 = s.sp.p2;
  var y2 = match$1.yi;
  var x2 = match$1.xi;
  var match$2 = x1 === x2;
  var match$3 = y1 === y2;
  if (match$2) {
    if (match$3) {
      if (x1 === i) {
        return y1 === j;
      } else {
        return false;
      }
    } else if (x1 === i) {
      return Math.imul(y1 - j | 0, y2 - j | 0) <= 0;
    } else {
      return false;
    }
  } else if (match$3 && y1 === j) {
    return Math.imul(x1 - i | 0, x2 - i | 0) <= 0;
  } else {
    return false;
  }
}

function findNearest(param, strokes, limit) {
  var y = param[1];
  var x = param[0];
  var gp = wToG([
        x,
        y
      ]);
  var xgf = (x - 20 | 0) / dotSpacing;
  var ygf = ((900 - y | 0) - 20 | 0) / dotSpacing;
  var dd = function (x, y, s) {
    var match = s.sp.p1;
    var x1 = match.xi;
    var match$1 = s.sp.p2;
    if (x1 === match$1.xi) {
      return Math.abs(x - x1);
    } else {
      return Math.abs(y - match.yi);
    }
  };
  var best = function (sAndDList) {
    if (!sAndDList) {
      return ;
    }
    var match = sAndDList.tl;
    var q1 = sAndDList.hd;
    if (!match) {
      return [
              q1[0],
              q1[1]
            ];
    }
    var match$1 = best({
          hd: match.hd,
          tl: match.tl
        });
    if (match$1 !== undefined) {
      var rDist = match$1[1];
      if (Caml_obj.caml_lessequal(q1[1], rDist)) {
        return q1;
      } else {
        return [
                match$1[0],
                rDist
              ];
      }
    }
    throw {
          RE_EXN_ID: "Match_failure",
          _1: [
            "Editor.re",
            435,
            12
          ],
          Error: new Error()
        };
  };
  var containingStrokes = List.filter(function (s) {
          return strokeContains(gp, s);
        })(strokes);
  var sAndD = List.map((function (s) {
          return [
                  s,
                  dd(xgf, ygf, s)
                ];
        }), containingStrokes);
  var limitedSAndD = List.filter(function (param) {
          return param[1] <= limit;
        })(sAndD);
  var match = best(limitedSAndD);
  if (match !== undefined) {
    return match[0];
  }
  
}

function updateState(state, env) {
  var press = Reprocessing_Env.mousePressed(env);
  var release = state.dragging && !press;
  var shift = Reprocessing_Env.key(/* LeftShift */57, env) || Reprocessing_Env.key(/* RightShift */61, env);
  var mouse = Reprocessing_Env.mousePressed(env);
  var match = Reprocessing_Env.mouse(env);
  var y = match[1];
  var x = match[0];
  var loc = wToG([
        x,
        y
      ]);
  var s = state.p;
  var newPhase;
  var exit = 0;
  switch (s) {
    case /* Base */0 :
    case /* Shift */1 :
        exit = 1;
        break;
    case /* DelStart */2 :
        newPhase = /* DelDone */3;
        break;
    case /* DelDone */3 :
    case /* Neutral */4 :
        exit = 2;
        break;
    case /* Dragging */5 :
        newPhase = shift ? (
            mouse ? /* Dragging */5 : /* Shift */1
          ) : (
            mouse ? /* Dragging */5 : /* Base */0
          );
        break;
    
  }
  switch (exit) {
    case 1 :
        newPhase = shift ? (
            mouse ? /* DelStart */2 : /* Shift */1
          ) : (
            mouse ? /* Dragging */5 : /* Base */0
          );
        break;
    case 2 :
        newPhase = shift ? (
            mouse ? /* DelDone */3 : /* Shift */1
          ) : (
            mouse ? /* Neutral */4 : /* Base */0
          );
        break;
    
  }
  var newDragStart = state.p === /* Base */0 && newPhase === /* Dragging */5 ? loc : state.dragStart;
  var newDragNow = state.p === /* Dragging */5 && newPhase === /* Dragging */5 ? align(state.dragStart, loc) : state.dragStart;
  var newStrokeList;
  if (state.p === /* Dragging */5 && newPhase !== /* Dragging */5) {
    newStrokeList = clean({
          hd: {
            sp: {
              p1: state.dragStart,
              p2: align(state.dragStart, loc)
            },
            color: rColor(undefined)
          },
          tl: state.strokeList
        }, env);
  } else if (state.p === /* DelStart */2 && newPhase === /* DelDone */3) {
    var closest = findNearest([
          x,
          y
        ], state.strokeList, 0.5);
    newStrokeList = closest !== undefined ? List.filter(function (s) {
              if (Caml_obj.caml_notequal(s.sp.p1, closest.sp.p1)) {
                return true;
              } else {
                return Caml_obj.caml_notequal(s.sp.p2, closest.sp.p2);
              }
            })(state.strokeList) : state.strokeList;
  } else {
    newStrokeList = state.strokeList;
  }
  return {
          p: newPhase,
          dragging: press ? true : (
              release ? false : state.dragging
            ),
          dragStart: newDragStart,
          dragNow: newDragNow,
          strokeColor: state.strokeColor,
          strokeList: Caml_obj.caml_notequal(newStrokeList, state.strokeList) ? (dataCarrier.strokes = newStrokeList, newStrokeList) : state.strokeList,
          dots: state.dots,
          oldStrokes: Caml_obj.caml_notequal(newStrokeList, state.strokeList) ? state.strokeList : state.oldStrokes
        };
}

function draw(state, env) {
  Reprocessing_Draw.background(bgColor, env);
  drawGrid(state, env);
  drawFrame(state, env);
  drawStrokes(state, env);
  drawCurrentLine(state, env);
  return updateState(state, env);
}

var displayWidth = 900;

var displayHeight = 900;

var slatHeight = 30.0;

var materialThickness = 3.0;

var frameWidth = 65.0;

var frameHeight = 85.0;

var dipPercentage = 75.0;

var includeFrame = true;

var dotGap = 10.0;

var margin = 20;

var dotRadius = 2.5;

var lineWidth = 2;

var frameLineWidth = 7;

var randomStrokeColors = true;

export {
  displayWidth ,
  displayHeight ,
  slatHeight ,
  materialThickness ,
  frameWidth ,
  frameHeight ,
  dipPercentage ,
  includeFrame ,
  dotGap ,
  extendedWidth ,
  extendedHeight ,
  margin ,
  ratio ,
  dotSpacing ,
  wCount ,
  hCount ,
  drawingHeight ,
  drawingWidth ,
  dotRadius ,
  lineWidth ,
  frameLineWidth ,
  randomStrokeColors ,
  bgColor ,
  basicStrokeColor ,
  dragLineColor ,
  dotColor ,
  frameColor ,
  dataCarrier ,
  getStrokes ,
  rColor ,
  wToG ,
  gToW ,
  makeOuterStrokes ,
  intSegment ,
  makeDots ,
  nonDegenerate ,
  orderY ,
  orderX ,
  compXY ,
  compYX ,
  overlapH ,
  overlapV ,
  mergeH ,
  mergeV ,
  toString ,
  showStrokes ,
  merge ,
  clean ,
  setup ,
  drawFrame ,
  drawGrid ,
  drawStrokes ,
  drawCurrentLine ,
  align ,
  strokeContains ,
  findNearest ,
  updateState ,
  draw ,
  
}
/* extendedWidth Not a pure module */
