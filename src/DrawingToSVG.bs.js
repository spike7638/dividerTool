// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";
import * as List from "rescript/lib/es6/list.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";

function converterProducer(w, g, t, n) {
  if (n >= (w - t) / g) {
    return w - t;
  } else {
    return n * g;
  }
}

function gToWH(param) {
  return converterProducer(220.0, 30.0, 5.0, param);
}

function classifyH(y, spans) {
  return List.map((function (s) {
                return {
                        m: s.p1.yi === y || s.p2.yi === y ? /* Terminate */1 : /* Cross */0,
                        pos: s.p1.xi
                      };
              }), spans);
}

function convertHelper(ss, sf, n, meets) {
  if (!meets) {
    return Pervasives.failwith("Empty meets-list in convertHelper!");
  }
  var match = meets.tl;
  var match$1 = meets.hd;
  var k = match$1.pos;
  var q = match$1.m;
  if (match) {
    var tl = match.tl;
    var match$2 = match.hd;
    var l = match$2.pos;
    var r = match$2.m;
    if (k !== n) {
      return Pervasives.failwith("Bad position in spanSummary!");
    }
    var fill = {
      TAG: /* G */6,
      _0: gToWH(l) - gToWH(k)
    };
    var fillShort = {
      TAG: /* G */6,
      _0: gToWH(l) - (gToWH(k) + 5.0)
    };
    switch (q) {
      case /* Cross */0 :
          if (k !== ss) {
            return {
                    hd: {
                      TAG: /* XU */2,
                      _0: 5.0
                    },
                    tl: {
                      hd: fillShort,
                      tl: convertHelper(ss, sf, l, {
                            hd: {
                              m: r,
                              pos: l
                            },
                            tl: tl
                          })
                    }
                  };
          } else {
            return {
                    hd: {
                      TAG: /* T */5,
                      _0: 5.0
                    },
                    tl: {
                      hd: fillShort,
                      tl: convertHelper(ss, sf, l, {
                            hd: {
                              m: r,
                              pos: l
                            },
                            tl: tl
                          })
                    }
                  };
          }
      case /* Terminate */1 :
          if (k === ss) {
            return {
                    hd: {
                      TAG: /* CU */0,
                      _0: 5.0
                    },
                    tl: {
                      hd: fillShort,
                      tl: convertHelper(ss, sf, l, {
                            hd: {
                              m: r,
                              pos: l
                            },
                            tl: tl
                          })
                    }
                  };
          } else {
            return {
                    hd: {
                      TAG: /* S */4,
                      _0: 5.0
                    },
                    tl: {
                      hd: fillShort,
                      tl: convertHelper(ss, sf, l, {
                            hd: {
                              m: r,
                              pos: l
                            },
                            tl: tl
                          })
                    }
                  };
          }
      case /* End */2 :
          return {
                  hd: fill,
                  tl: convertHelper(ss, sf, l, {
                        hd: {
                          m: r,
                          pos: l
                        },
                        tl: tl
                      })
                };
      
    }
  } else {
    if (k !== n) {
      return Pervasives.failwith("Bad position in spanSummary!");
    }
    switch (q) {
      case /* Cross */0 :
          if (sf !== n) {
            return {
                    hd: {
                      TAG: /* XU */2,
                      _0: 5.0
                    },
                    tl: {
                      hd: {
                        TAG: /* G */6,
                        _0: gToWH(sf) - gToWH(n)
                      },
                      tl: /* [] */0
                    }
                  };
          } else {
            return {
                    hd: {
                      TAG: /* T */5,
                      _0: 5.0
                    },
                    tl: /* [] */0
                  };
          }
      case /* Terminate */1 :
          if (sf !== n) {
            return {
                    hd: {
                      TAG: /* S */4,
                      _0: 5.0
                    },
                    tl: {
                      hd: {
                        TAG: /* G */6,
                        _0: gToWH(sf) - gToWH(n)
                      },
                      tl: /* [] */0
                    }
                  };
          } else {
            return {
                    hd: {
                      TAG: /* CU */0,
                      _0: 5.0
                    },
                    tl: /* [] */0
                  };
          }
      case /* End */2 :
          return {
                  hd: {
                    TAG: /* G */6,
                    _0: gToWH(sf) + 5.0 - gToWH(n)
                  },
                  tl: /* [] */0
                };
      
    }
  }
}

function enhance(s, flist) {
  if (!flist) {
    return {
            hd: {
              m: /* End */2,
              pos: s.p1.xi
            },
            tl: {
              hd: {
                m: /* End */2,
                pos: s.p2.xi
              },
              tl: /* [] */0
            }
          };
  }
  var nFeature = List.length(flist);
  var lastFeature = List.nth(flist, nFeature - 1 | 0);
  var fixedLast = lastFeature.pos !== s.p2.xi ? Pervasives.$at(flist, {
          hd: {
            m: /* End */2,
            pos: s.p2.xi
          },
          tl: /* [] */0
        }) : flist;
  if (flist.hd.pos !== s.p1.xi) {
    return {
            hd: {
              m: /* End */2,
              pos: s.p1.xi
            },
            tl: fixedLast
          };
  } else {
    return fixedLast;
  }
}

function cleanup(_ss) {
  while(true) {
    var ss = _ss;
    if (!ss) {
      return /* [] */0;
    }
    var q = ss.hd;
    if (!ss.tl) {
      return {
              hd: q,
              tl: /* [] */0
            };
    }
    if (q.TAG !== /* G */6) {
      return {
              hd: q,
              tl: cleanup(ss.tl)
            };
    }
    var match = ss.tl;
    var b = match.hd;
    if (b.TAG !== /* G */6) {
      return {
              hd: q,
              tl: cleanup(ss.tl)
            };
    }
    _ss = {
      hd: {
        TAG: /* G */6,
        _0: q._0 + b._0
      },
      tl: match.tl
    };
    continue ;
  };
}

function convertOne(s, spans) {
  var span1 = classifyH(s.p1.yi, spans);
  var spanSummaries = enhance(s, span1);
  return cleanup(convertHelper(s.p1.xi, s.p2.xi, s.p1.xi, spanSummaries));
}

function swap(s) {
  return {
          p1: s.p2,
          p2: s.p1
        };
}

function isHorizontal(s) {
  return s.p1.yi === s.p2.yi;
}

function meets(h, v) {
  if (h.p1.yi >= v.p1.yi && h.p1.yi <= v.p2.yi && h.p1.xi <= v.p1.xi) {
    return h.p2.xi >= v.p1.xi;
  } else {
    return false;
  }
}

function polish(s) {
  if (isHorizontal(s)) {
    if (s.p1.xi < s.p2.xi) {
      return s;
    } else {
      return swap(s);
    }
  } else if (s.p1.yi < s.p2.yi) {
    return s;
  } else {
    return swap(s);
  }
}

function flipPoint(p) {
  return {
          xi: p.yi,
          yi: p.xi
        };
}

function flipSpan(s) {
  return polish({
              p1: flipPoint(s.p1),
              p2: flipPoint(s.p2)
            });
}

function flipSpanList(s) {
  return List.map(flipSpan, s);
}

function flipFeature(q) {
  switch (q.TAG | 0) {
    case /* CU */0 :
        return {
                TAG: /* CL */1,
                _0: q._0
              };
    case /* CL */1 :
        return {
                TAG: /* CU */0,
                _0: q._0
              };
    case /* XU */2 :
        return {
                TAG: /* XL */3,
                _0: q._0
              };
    case /* XL */3 :
        return {
                TAG: /* XU */2,
                _0: q._0
              };
    default:
      return q;
  }
}

function flipFeatureList(x) {
  return List.map(flipFeature, x);
}

function flipFeatureListList(x) {
  return List.map(flipFeatureList, x);
}

function prepAndConvert(hSpans, vSpans) {
  var qq = function (s) {
    var crosses = List.filter(function (v) {
            return meets(s, v);
          })(vSpans);
    var cross2 = List.sort((function (s1, s2) {
            return Caml.caml_int_compare(s1.p1.xi, s2.p1.xi);
          }), crosses);
    return convertOne(s, cross2);
  };
  return List.fold_right((function (x, r) {
                return {
                        hd: qq(x),
                        tl: r
                      };
              }), hSpans, /* [] */0);
}

function convertAll(drawing) {
  var d = List.map(polish, drawing);
  var dH = List.filter(isHorizontal)(d);
  var dV = List.filter(function (x) {
          return !isHorizontal(x);
        })(d);
  var fH = prepAndConvert(dH, dV);
  var fV = List.map(flipFeatureList, prepAndConvert(List.map(flipSpan, dV), List.map(flipSpan, dH)));
  return Pervasives.$at(fH, fV);
}

function soi(prim) {
  return String(prim);
}

function string_of_feature(q) {
  switch (q.TAG | 0) {
    case /* CU */0 :
        return "CU(" + (Pervasives.string_of_float(q._0) + ")");
    case /* CL */1 :
        return "CL(" + (Pervasives.string_of_float(q._0) + ")");
    case /* XU */2 :
        return "XU(" + (Pervasives.string_of_float(q._0) + ")");
    case /* XL */3 :
        return "XL(" + (Pervasives.string_of_float(q._0) + ")");
    case /* S */4 :
        return "S(" + (Pervasives.string_of_float(q._0) + ")");
    case /* T */5 :
        return "T(" + (Pervasives.string_of_float(q._0) + ")");
    case /* G */6 :
        return "G(" + (Pervasives.string_of_float(q._0) + ")");
    case /* D */7 :
        return "D(" + (Pervasives.string_of_float(q._0) + ")");
    
  }
}

function string_of_direction(q) {
  if (q) {
    return "V";
  } else {
    return "H";
  }
}

function string_of_meeting(q) {
  switch (q) {
    case /* Cross */0 :
        return "Cross";
    case /* Terminate */1 :
        return "Term";
    case /* End */2 :
        return "End";
    
  }
}

function string_of_span_summaryi(param) {
  return "ss: " + (string_of_meeting(param.m) + (", " + String(param.pos)));
}

function spanList_of_strokeList(sl) {
  return List.map((function (s) {
                return s.sp;
              }), sl);
}

function converter(sl) {
  return convertAll(List.map((function (s) {
                    return s.sp;
                  }), sl));
}

var frameWidth = 220.0;

var gridSpacing = 30.0;

var thickness = 5.0;

var t = 5.0;

var sof = Pervasives.string_of_float;

export {
  frameWidth ,
  gridSpacing ,
  thickness ,
  t ,
  converterProducer ,
  gToWH ,
  classifyH ,
  convertHelper ,
  enhance ,
  cleanup ,
  convertOne ,
  swap ,
  isHorizontal ,
  meets ,
  polish ,
  flipPoint ,
  flipSpan ,
  flipSpanList ,
  flipFeature ,
  flipFeatureList ,
  flipFeatureListList ,
  prepAndConvert ,
  convertAll ,
  soi ,
  sof ,
  string_of_feature ,
  string_of_direction ,
  string_of_meeting ,
  string_of_span_summaryi ,
  spanList_of_strokeList ,
  converter ,
  
}
/* No side effect */
